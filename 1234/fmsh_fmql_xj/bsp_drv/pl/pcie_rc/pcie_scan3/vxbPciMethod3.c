/*
 * Copyright (c) 2016 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/*
 *  DO NOT MODIFY THIS FILE MANUALLY
 *
 *  This file is automatically generated from
 *  the method file (extended with *.m).
 *
 */
 
#include "vxbPciMethod3.h"
#include "vxbPciLib3.h"
#include "dllLib3.h"
/*
*/

extern int XAxiPcie_ReadRemote_CfgSpace2( UINT8 PCIeBusNum, UINT8 PCIeDevNum, UINT8 PCIeFunNum, UINT16 Offset, UINT32 *DataPtr);
extern int XAxiPcie_WriteRemote_CfgSpace2(UINT8 PCIeBusNum, UINT8 PCIeDevNum, UINT8 PCIeFunNum, UINT16 Offset, UINT32 Data);

#if 1
STATUS VXB_PCI_CFG_READ_3 (VXB_DEV_ID3 pDev,  PCI_HARDWARE_3 * pciDev, UINT32 offset, UINT32 width, void * data)
{
	UINT8 PCIeBusNum, PCIeDevNum, PCIeFunNum;
	UINT32 tmp32 = 0;
	UINT32 reg_idx = 0;
	
	PCIeBusNum = pciDev->pciBus;
	PCIeDevNum = pciDev->pciDev; 
	PCIeFunNum = pciDev->pciFunc;

	reg_idx = (offset / 4 );
	/*printf("VXB_PCI_CFG_READ_3: %d-%d-%d = reg_idx: %d \n", PCIeBusNum, PCIeDevNum, PCIeFunNum, reg_idx);*/

	if (OK != XAxiPcie_ReadRemote_CfgSpace2(PCIeBusNum, PCIeDevNum, PCIeFunNum, reg_idx, &tmp32))
	{
		return ERROR;
	}

	switch (width)
	{
	case 1:  /* 1 byte*/
		switch (offset % 4)
		{
		case 0:  /* byte_idx_0*/
			*(UINT8*)data = (UINT8)(tmp32 & 0xFF);
			break;
		case 1:  /* byte_idx_1*/
			*(UINT8*)data = (UINT8)((tmp32 & 0xFF00) >> 8);
			break;
		case 2:  /* byte_idx_2*/
			*(UINT8*)data = (UINT8)((tmp32 & 0xFF0000) >> 16);
			break;
		case 3:  /* byte_idx_3*/
			*(UINT8*)data = (UINT8)((tmp32 & 0xFF000000) >> 24);
			break;
		}
		break;

	case 2:  /* 2 bytes, short*/
		switch (offset % 4)
		{
		case 0:
			*(UINT16*)data = (UINT16)(tmp32 & 0xFFFF);
			break;
		case 2:
			*(UINT16*)data = (UINT16)((tmp32 & 0xFFFF0000) >> 16);
			break;
		}
		break;

	case 4:  /* 4 bytes, long*/
		*(UINT32*)data = tmp32;
		break;			
	}

	return OK;
}


STATUS VXB_PCI_CFG_WRITE_3 (VXB_DEV_ID3 pDev,  PCI_HARDWARE_3 * pciDev, UINT32 offset, UINT32 width, UINT32 data)
{
	UINT8 PCIeBusNum, PCIeDevNum, PCIeFunNum;
	UINT32 tmp32 = 0;
	UINT32 reg_idx = 0;
	
	PCIeBusNum = pciDev->pciBus;
	PCIeDevNum = pciDev->pciDev; 
	PCIeFunNum = pciDev->pciFunc;
	
	reg_idx = (offset / 4 );
	/*printf("VXB_PCI_CFG_WRITE_3: %d-%d-%d = reg_idx: %d \n", PCIeBusNum, PCIeDevNum, PCIeFunNum, reg_idx);*/
	
	if (OK != XAxiPcie_ReadRemote_CfgSpace2(PCIeBusNum, PCIeDevNum, PCIeFunNum, reg_idx, &tmp32))
	{
		return ERROR;
	}

	switch (width)
	{
	case 1:  /* 1 byte*/
		switch (offset % 4)
		{
		case 0:  /* byte_idx_0*/
			tmp32 &= (UINT32)(~0xFF);
			tmp32 |= (UINT32)(data & 0xFF); 
			break;
		case 1:  /* byte_idx_1*/
			tmp32 &= (UINT32)(~0xFF00);
			tmp32 |= (UINT32)((data & 0xFF) << 8); 
			break;
		case 2:  /* byte_idx_2*/
			tmp32 &= (UINT32)(~0xFF0000);
			tmp32 |= (UINT32)((data & 0xFF) << 16); 
			break;
		case 3:  /* byte_idx_3*/
			tmp32 &= (UINT32)(~0xFF000000);
			tmp32 |= (UINT32)((data & 0xFF) << 24); 
			break;
		}
		break;

	case 2:  /* 2 bytes, short*/
		switch (offset % 4)
		{
		case 0:
			tmp32 &= (UINT32)(~0xFFFF);
			tmp32 |= (UINT32)(data & 0xFFFF); 
			break;
		case 2:
			tmp32 &= (UINT32)(~0xFFFF0000);
			tmp32 |= (UINT32)((data & 0xFFFF) << 16); 
			break;
		}
		break;

	case 4:  /* 4 bytes, long*/
		tmp32 = data;
		break;			
	}

	if (OK != XAxiPcie_WriteRemote_CfgSpace2(PCIeBusNum, PCIeDevNum, PCIeFunNum, reg_idx, tmp32))	
	{
		return ERROR;
	}
	
	return OK;
}

#endif
